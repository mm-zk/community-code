# How Max Gas Per Pubdata Works on ZKsync Era--A Technical Deep Dive

## Introduction

ZKsync Era, a Layer 2 scaling solution for Ethereum, introduces a unique concept called "max gas per pubdata." This article explains what it is,
how it works, and demonstrates its usage with a practical example.

## What is Max Gas Per Pubdata?

Max gas per pubdata is a value attached to each transaction on ZKsync Era, representing the maximum amount of gas a user is willing to
pay for each byte of pubdata (public data) published on Ethereum.

Key points:

1. Default value: 50,000 gas per pubdata byte
2. Can be customized per transaction
3. Affects transaction success and cost

## How It Works

1. **Transaction Submission**: When sending a transaction, you specify the max gas per pubdata.
2. **Execution**: ZKsync executes the transaction and calculates the actual pubdata cost.
3. **Comparison**: The actual cost is compared against your specified max value.
4. **Outcome**:
   - If actual cost â‰¤ specified max: Transaction succeeds
   - If actual cost > specified max: Transaction fails

## Why ZKsync Chose This Approach

1. Flexibility in adjusting to L1 gas price fluctuations
2. Allows users to set limits on pubdata costs
3. Optimizes L1 data availability costs

## Technical Example: ZKFest Voting Contract

Let's examine how max gas per pubdata works with a real contract

### ZKFestVoting Contract

```solidity
contract ZKFestVoting {
    mapping(address => uint8) public participation;

    function vote(string memory stageName) external {
        uint256 stageIndex = getStageIndex(stageName);
        require(stageIndex < 3, "Invalid stage");
        uint256 stageBit = 1 << stageIndex;
        
        require((participation[msg.sender] & stageBit) == 0, "Already voted for this stage");

        emit Voted(msg.sender, Stage(stageIndex));
    }
    // ... other functions ...

}

```

### Deployment and interaction script

```typescript
import { deployContract, getProvider, getWallet } from "./utils";
import { Deployer } from "@matterlabs/hardhat-zksync";
import * as hre from "hardhat";
import { ethers } from "ethers";

export default async function () {
    const wallet = getWallet();
    const deployer = new Deployer(hre, wallet);
    
    // Deploy contract
    const artifact = await deployer.loadArtifact("ZKFestVotingByName");
    const contract = await deployContract("ZKFestVotingByName", []);

    // Function to send transaction with custom gas settings
    const sendAndExplainTx = async (gasPerPubdata: string | number, gasLimit: string | number) => {
        console.log(`Testing with gasPerPubdata: ${gasPerPubdata}, gasLimit: ${gasLimit}`);
        try {
            const customTx = await createCustomTx(gasPerPubdata, gasLimit);
            const txResponse = await wallet.sendTransaction(customTx);
            const receipt = await txResponse.wait();
            console.log(`Gas used: ${receipt.gasUsed}`);
        } catch (error) {
            console.error("Transaction failed:", error);
        }
    };

    // Create custom transaction
    const createCustomTx = async (gasPerPubdata: string | number, gasLimit: string | number) => {
        const voteFunctionData = contract.interface.encodeFunctionData("vote", ["Culture"]);
        return {
            to: await contract.getAddress(),
            data: voteFunctionData,
            gasLimit: ethers.getBigInt(gasLimit),
            customData: {
                gasPerPubdata: ethers.getBigInt(gasPerPubdata)
            }
        };
    };

    // Test different scenarios
    await sendAndExplainTx(utils.DEFAULT_GAS_PER_PUBDATA_LIMIT, "2000000");
    await sendAndExplainTx("100", "2000000"); // Very low gasPerPubdata
    await sendAndExplainTx(utils.DEFAULT_GAS_PER_PUBDATA_LIMIT, "100000000"); // Very high gasLimit
}
```

This script demonstrates:

1. Deploying the ZKFestVotingByName contract
2. Creating transactions with custom gas per pubdata settings
3. Testing different scenarios to observe the impact of gas per pubdata

## Block Explorer View

After running these transactions, you can verify their execution on the ZKsync Era block explorer. Here's an example of what you might see:

[insert picture]

This real transaction shows:

1. The default gas per pubdata (50,000) was sufficient
2. Only 4.28% of the gas limit was used, indicating efficiency
3. The low fee demonstrates ZKsync Era's cost-effectiveness

## Conclusion

Understanding and properly configuring max gas per pubdata is crucial for efficient development on ZKsync Era. By carefully managing this
parameter, developers can create more economical and user-friendly decentralized applications while leveraging zkSync's scaling benefits.
